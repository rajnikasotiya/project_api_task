.
├── main.py
├── api
│   └── routes.py
├── core
│   └── exceptions.py
├── models
│   └── schemas.py
├── requirements.txt



#models/schemas.py

from pydantic import BaseModel, Field, UUID4, validator, root_validator
from typing import Optional, List, Dict
from enum import Enum


# ENUMS FOR VALIDATION
class TaskNameEnum(str, Enum):
    extractive_summarization = "extractive_summarization"
    abstractive_summarization = "abstractive_summarization"
    classification = "classification"


class RequestorTypeEnum(str, Enum):
    member = "member"
    provider = "provider"


class ReadingLevelEnum(str, Enum):
    eighth_grade = "8th_grade"


class DocumentTypeEnum(str, Enum):
    transcription = "transcription"
    document = "document"


# 5Ws RESPONSE CONTAINER
class Extraction5WsContainer(BaseModel):
    Who: str
    What: str
    When: str
    Where: str
    Why: str


# SECTION: INSTRUCTIONS
class Instructions(BaseModel):
    TaskName: TaskNameEnum
    RequestorType: RequestorTypeEnum
    ReadingLevel: Optional[ReadingLevelEnum] = None


# SECTION: DOCUMENT
class Document(BaseModel):
    DocumentType: DocumentTypeEnum
    Metadata: Dict
    Content: str
    PriorAuth: Optional[List[str]] = Field(default_factory=list)
    InteractionID: Optional[UUID4] = None
    DCN: Optional[str] = None

    @validator("DCN")
    def validate_dcn(cls, v):
        if v and not v.isalnum():
            raise ValueError("DCN must be alphanumeric")
        return v


# SECTION: SOURCES
class Sources(BaseModel):
    Guidelines: Optional[List[str]] = Field(default_factory=list)
    Glossary: Optional[List[str]] = Field(default_factory=list)


# SECTION: INDICATORS
class Indicators(BaseModel):
    Citation: bool
    Reasoning: bool

    @root_validator
    def check_citation_reasoning(cls, values):
        if values.get("Citation") and not values.get("Reasoning"):
            raise ValueError("Reasoning must be true if Citation is true.")
        return values


# MASTER REQUEST MODEL
class TaskRequest(BaseModel):
    Instructions: Instructions
    Document: Document
    Sources: Optional[Sources] = Sources()
    Indicators: Indicators


# RESPONSE MODEL
class TaskResponse(BaseModel):
    TaskName: str
    ResponseContainer: Extraction5WsContainer





##############api/routes.py

from fastapi import APIRouter, HTTPException
from models.schemas import TaskRequest, TaskResponse, Extraction5WsContainer

router = APIRouter()


@router.get("/capabilities")
def get_capabilities():
    """
    Return the list of supported models.
    """
    return {"models": ["o3-mini-openai"]}


@router.post("/heartbeat")
async def heartbeat():
    """
    Simple POST to confirm service is alive.
    """
    return {"status": 200, "Info": "OK", "Role": "Mock Response"}


@router.post("/task", response_model=TaskResponse)
async def handle_task(payload: TaskRequest):
    """
    Main task handler that processes structured requests and returns extracted content.
    """
    try:
        task_name = payload.Instructions.TaskName

        # Example response payload - replace with logic
        response = Extraction5WsContainer(
            Who="Dr. John Smith",
            What="Requested authorization for spinal MRI",
            When="2025-06-11",
            Where="City Hospital",
            Why="Suspected herniated disc"
        )

        return TaskResponse(TaskName=task_name, ResponseContainer=response)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal error: {str(e)}")



########core/exceptions.py


from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from pydantic import ValidationError

def register_exception_handlers(app: FastAPI):
    @app.exception_handler(ValidationError)
    async def validation_exception_handler(request: Request, exc: ValidationError):
        return JSONResponse(
            status_code=422,
            content={"error": "Validation failed", "details": exc.errors()},
        )

    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        return JSONResponse(
            status_code=500,
            content={"error": "Internal Server Error", "message": str(exc)},
        )



#################   main.py

from fastapi import FastAPI
from core.exceptions import register_exception_handlers
from api.routes import router as api_router

app = FastAPI(title="Task Processor API", description="Processes medical task requests", version="1.1")

app.include_router(api_router)
register_exception_handlers(app)



##############.
├── tests
│   └── test_api.py
├── main.py
├── models/
├── api/
├── core/
├── requirements.txt





######## requirements.txt
fastapi
uvicorn
pydantic
pytest
httpx



########    tests/test_api.py



import pytest
from httpx import AsyncClient
from main import app


@pytest.mark.asyncio
async def test_get_capabilities():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/capabilities")
    assert response.status_code == 200
    assert "models" in response.json()
    assert "o3-mini-openai" in response.json()["models"]


@pytest.mark.asyncio
async def test_post_heartbeat():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.post("/heartbeat")
    assert response.status_code == 200
    assert response.json()["Info"] == "OK"


@pytest.mark.asyncio
async def test_valid_task_request():
    payload = {
        "Instructions": {
            "TaskName": "extractive_summarization",
            "RequestorType": "member",
            "ReadingLevel": "8th_grade"
        },
        "Document": {
            "DocumentType": "transcription",
            "Metadata": {"source": "CallCenter"},
            "Content": "Patient called requesting MRI for back pain...",
            "PriorAuth": ["AUTH123"],
            "InteractionID": "550e8400-e29b-41d4-a716-446655440000",
            "DCN": "ABC123"
        },
        "Sources": {
            "Guidelines": ["Guideline1"],
            "Glossary": ["Term1"]
        },
        "Indicators": {
            "Citation": True,
            "Reasoning": True
        }
    }

    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.post("/task", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["TaskName"] == "extractive_summarization"
    assert "ResponseContainer" in data
    assert all(k in data["ResponseContainer"] for k in ["Who", "What", "When", "Where", "Why"])


@pytest.mark.asyncio
async def test_invalid_task_missing_reasoning():
    payload = {
        "Instructions": {
            "TaskName": "classification",
            "RequestorType": "provider"
        },
        "Document": {
            "DocumentType": "document",
            "Metadata": {},
            "Content": "Test",
            "PriorAuth": [],
            "DCN": "123!@#"
        },
        "Indicators": {
            "Citation": True,
            "Reasoning": False
        }
    }

    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.post("/task", json=payload)

    assert response.status_code == 422 or response.status_code == 500
    assert "error" in response.text.lower()







#pytest tests/





















##############################


except NetworkException as ne:
        logger.error(f"Network error: {ne.detail}")
        raise ne
    except LLMProviderException as le:
        logger.error(f"LLM provider error: {le.detail}")
        raise le
    except TimeoutException as te:
        logger.error(f"Timeout error: {te.detail}")
        raise te



logger.error(f"Unhandled error in /generate: {str(e)}")
        raise NextGenException(detail=f"Unhandled error in /generate: {str(e)}")



class ErrorCode:
    SUCCESS = 200
    BAD_REQUEST = 400
    UNAUTHORIZED = 401
    FORBIDDEN = 403
    NOT_FOUND = 404
    SERVER_ERROR = 500
    CUSTOM_VALIDATION_ERROR = 422
    NETWORK_ERROR = 503
    LLM_PROVIDER_ERROR = 520  # Custom code for LLM provider errors
    TIMEOUT_ERROR = 504






from fastapi import HTTPException
from app.config.error_codes import ErrorCode

class NextGenException(HTTPException):
    def __init__(self, status_code: int = ErrorCode.SERVER_ERROR, detail: str = "An error occurred", headers: dict = None):
        super().__init__(status_code=status_code, detail=detail, headers=headers)

class InvalidPayloadException(NextGenException):
    def __init__(self, detail: str = "Invalid input payload"):
        super().__init__(status_code=ErrorCode.BAD_REQUEST, detail=detail)

class NotFoundException(NextGenException):
    def __init__(self, detail: str = "Resource not found"):
        super().__init__(status_code=ErrorCode.NOT_FOUND, detail=detail)

class UnauthorizedException(NextGenException):
    def __init__(self, detail: str = "Unauthorized access"):
        super().__init__(status_code=ErrorCode.UNAUTHORIZED, detail=detail)

class ForbiddenException(NextGenException):
    def __init__(self, detail: str = "Access forbidden"):
        super().__init__(status_code=ErrorCode.FORBIDDEN, detail=detail)

class NetworkException(NextGenException):
    def __init__(self, detail: str = "Network error"):
        super().__init__(status_code=ErrorCode.NETWORK_ERROR, detail=detail)

class LLMProviderException(NextGenException):
    def __init__(self, detail: str = "LLM provider error"):
        super().__init__(status_code=ErrorCode.LLM_PROVIDER_ERROR, detail=detail)

class TimeoutException(NextGenException):
    def __init__(self, detail: str = "Request timed out"):
        super().__init__(status_code=ErrorCode.TIMEOUT_ERROR, detail=detail)









from pydantic import BaseModel, field_validator, model_validator, ValidationError
from typing import List, Optional
from app.exceptions.custom_exceptions import InvalidPayloadException

class Document(BaseModel):
    document_type: str
    metadata: dict
    content: str
    prior_auth: Optional[List[str]] = []
    interaction_id: Optional[str] = None
    dcn: Optional[str] = None

    @field_validator('document_type', mode='before')
    @classmethod
    def validate_document_type(cls, v):
        if not v or not isinstance(v, str):
            raise InvalidPayloadException(detail="document_type must be a non-empty string")
        return v

    @field_validator('content', mode='before')
    @classmethod
    def validate_content(cls, v):
        if not v or not isinstance(v, str):
            raise InvalidPayloadException(detail="content must be a non-empty string")
        return v

    @model_validator(mode='before')
    @classmethod
    def check_metadata(cls, values):
        metadata = values.get('metadata')
        if not isinstance(metadata, dict):
            raise InvalidPayloadException(detail="metadata must be a dictionary")
        return values

class TaskRequest(BaseModel):
    task_name: str
    requestor_type: Optional[str]
    reading_level: Optional[str]
    document: Document
    guidelines: Optional[List[str]] = []
    glossary: Optional[str] = None
    citation: bool = False
    reasoning: bool = False

    @field_validator('task_name', mode='before')
    @classmethod
    def validate_task_name(cls, v):
        if not v or not isinstance(v, str):
            raise InvalidPayloadException(detail="task_name must be a non-empty string")
        return v

    @model_validator(mode='after')
    @classmethod
    def post_validation(cls, values):
        if not values.citation and not values.reasoning:
            raise InvalidPayloadException(detail="At least one of citation or reasoning must be True")
        return values








from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from app.exceptions.custom_exceptions import (
    NextGenException, InvalidPayloadException, NotFoundException, NetworkException, LLMProviderException, TimeoutException
)
from app.config.error_codes import ErrorCode
from app.models.request import TaskRequest
from app.services.llm_service import process_task
from app.config.logger import logger
from pydantic import ValidationError

router = APIRouter()

@router.get("/", tags=["Index"])
def index():
    logger.info("NextGen API is live!")
    return {"message": "NextGen API is live!"}

@router.get("/capabilities", tags=["Core"])
async def get_capabilities():
    try:
        models = ["03-mini-openai", "gpt-4", "llama-3"]
        logger.info("Fetching capabilities")
        return JSONResponse(status_code=ErrorCode.SUCCESS, content={"models": models})
    except Exception as e:
        logger.error(f"Error in /capabilities: {str(e)}")
        raise NextGenException(detail=f"Error in /capabilities: {str(e)}")


@router.post("/heartbeat", tags=["Core"])
async def heartbeat():
    try:
        logger.info("Heartbeat check")
        return JSONResponse(status_code=ErrorCode.SUCCESS, content={"info": "heartbeat OK", "role": "backend"})
    except Exception as e:
        logger.error(f"Error in /heartbeat: {str(e)}")
        raise NextGenException(detail=f"Error in /heartbeat: {str(e)}")


@router.post("/generate", tags=["LLM"])
async def generate_5ws(request: TaskRequest):
    try:
        logger.info(f"Received task: {request.task_name}")
        response = await process_task(request)
        return JSONResponse(status_code=ErrorCode.SUCCESS, content=response)
    except (ValidationError, RequestValidationError) as ve:
        logger.warning(f"Validation error: {ve}")
        raise InvalidPayloadException(detail=str(ve))
    except InvalidPayloadException as ipe:
        logger.warning(f"Invalid payload: {ipe.detail}")
        raise ipe
    except NetworkException as ne:
        logger.error(f"Network error: {ne.detail}")
        raise ne
    except LLMProviderException as le:
        logger.error(f"LLM provider error: {le.detail}")
        raise le
    except TimeoutException as te:
        logger.error(f"Timeout error: {te.detail}")
        raise te
    except NextGenException as ne:
        logger.error(f"NextGen error: {ne.detail}")
        raise ne
    except Exception as e:
        logger.error(f"Unhandled error in /generate: {str(e)}")
        raise NextGenException(detail=f"Unhandled error in /generate: {str(e)}")






===================================
from typing import Optional, List
from pydantic import BaseModel, Field, field_validator

class Instructions(BaseModel):
    """
    Model for instructions in the request payload.

    Attributes:
        task_name (TaskName): The task to perform (e.g., extract, summarize).
        requestor_type (Optional[RequestorType]): Type of person or entity making the request.
        reading_level (Optional[ReadingLevel]): Complexity level of the response content.
    """
    task_name: TaskName = Field(..., description="The name of the task to perform")
    requestor_type: Optional[RequestorType] = Field(default=None, description="Type of requestor")
    reading_level: Optional[ReadingLevel] = Field(default=None, description="Desired reading level of the response")

    @field_validator("task_name", mode="before")
    @classmethod
    def not_empty_task_name(cls, v):
        if v is None or (isinstance(v, str) and not v.strip()):
            raise ValueError("task_name must not be empty.")
        return v

class RequestPayload(BaseModel):
    """
    Model for the full request payload.

    Attributes:
        instructions (Instructions): Instructions for the task.
        document (Document): The document to process.
        sources (Sources): Guidelines and glossary.
        indicators (Indicators): Citation and reasoning flags.
    """
    instructions: Instructions = Field(..., description="Instructions for the task")
    document: Document = Field(..., description="Document to process")
    sources: Sources = Field(..., description="Guidelines and glossary")
    indicators: Indicators = Field(..., description="Citation and reasoning flags")

    model_config = dict(
        json_schema_extra={
            "example": {
                "instructions": {
                    "task_name": "five_ws_extraction",
                    "requestor_type": "provider",
                    "reading_level": "high_school"
                },
                "document": {
                    "document_type": "report",
                    "metadata": {"source": "hospital"},
                    "content": "Patient was diagnosed with hypertension.",
                    "prior_auth": ["AUTH456"],
                    "interaction_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
                    "dcn": "DOC123456"
                },
                "sources": {
                    "guidelines": ["Follow up in 2 weeks"],
                    "glossary": ["hypertension"]
                },
                "indicators": {
                    "citation": True,
                    "reasoning": False
                }
            }
        }
    )

